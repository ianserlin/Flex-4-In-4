.menu
  .title
    Know Your Stuff
    /
      = I18n.t("padawan_menu_title")
  %ul
    %li
      %a{ :href => "#flex" }
        What is Adobe Flex?
    %li
      %a{ :href => "#flashbuilder" }
        What is Adobe Flash Builder/Flex Builder?
    %li
      %a{ :href => "#mxml" }
        What is MXML?
    %li
      %a{ :href => "#as3" }
        What is ActionScript 3 (AS3)?
    %li
      %a{ :href => "#swf" }
        What is a SWF?
    %li
      %a{ :href => "#swc" }
        What is a SWC?
    %li
      %a{ :href => "#project" }
        What is a Flex Project?
    %li
      %a{ :href => "#libraryproject" }
        What is a Flex Library Project?
    %li
      %a{ :href => "#app" }
        What is an Application?
    %li
      %a{ :href => "#layout" }
        What is a layout?
    %li
      %a{ :href => "#component" }
        What is a component?
    %li
      %a{ :href => "#container" }
        What is a container?
    %li
      %a{ :href => "#skin" }
        What is a skin?
    %li
      %a{ :href => "#css" }
        What does CSS mean in regards to Flex?
    %li
      %a{ :href => "#state" }
        What is a State?
    %li
      %a{ :href => "#transition" }
        What is a Transition?
    %li
      %a{ :href => "#effect" }
        What is an effect?
    %li
      %a{ :href => "#event" }
        What is an event/event handler?
    %li
      %a{ :href => "#binding" }
        What is a binding?
    %li
      %a{ :href => "#trace" }
        What is trace()?
    %li
      %a{ :href => "#racetrack" }
        Bonus: What is the elastic racetrack?

.notice
  .title
    Padawan Series
  %p
    The information here is designed to take you from ground zero to speaking the lingo.
    On this one page are the foundational concepts that all the other series build on and wrapping your
    mind around the following ideas first will allow you to go so much faster later on.
  %p
    Train well and become one with the Flex.

%h3
  %a{ :name => "flex" }
    What is Adobe Flex?
%h3
  %a{ :name => "flashbuilder" }
    What is Adobe Flash Builder/Flex Builder?
%h3
  %a{ :name => "mxml" }
    What is MXML?
%h3
  %a{ :name => "as3" }
    What is ActionScript 3 (AS3)?
.definition
  %p
    Strongly-typed, object-oriented mix between Java and JavaScript with its own set of built-in classes and utilities.
%h3
  %a{ :name => "swf" }
    What is a SWF?
%h3
  %a{ :name => "swc" }
    What is a SWC?
%h3
  %a{ :name => "project" }
    What is a Flex Project?
%h3
  %a{ :name => "libraryproject" }
    What is a Flex Library Project?
%h3
  %a{ :name => "app" }
    What is an Application?
%h3
  %a{ :name => "layout" }
    What is a layout?
%h3
  %a{ :name => "component" }
    What is a component?
%h3
  %a{ :name => "container" }
    What is a container?
%h3
  %a{ :name => "skin" }
    What is a skin?
%h3
  %a{ :name => "css" }
    What does CSS mean in regards to Flex?
%h3
  %a{ :name => "state" }
    What is a State?
.definition
  %p
    Flex States are kind of similar to a CSS class, but way more powerful. Whereas in a CSS class you can change things like colors, font sizes, etc., 
    using a Flex State you can change 
    %em
      any 
    property on a component, which functions get called for events like click 
    and even which parts of the component are currently visible or not simply by switching the component's state.
  %p
    For instance, let's say you're making a toolbar component. It might have a "normal" state where it's size is 300px by 40px, but in the "expanded"
    state, its size should increase to maybe 350px by 400px. You can easily achieve this using just one component by specifying the two states in the
    following way:
  %p
    = partial 'padawan/state_example'
  %p
    Note the &lt;s:states/&gt; block where the two States for the toolbar are defined, the use of the [property].[state] syntax on the properties of the BorderContainer
    and the includeIn/exludeFrom directives on the two buttons. Also note that the default state of the component is the first one you define.
    If you get this, you now know 95% of what you need to know about Flex States.
  
%h3
  %a{ :name => "transition" }
    What is a Transition?
.definition
  %p
    Transitions and States go hand in hand. While a State defines how a component looks and behaves at any given point in time, the Transition
    specifies how a component gets from one state to another and can add a level of finesse to your application.
  %p
    For example, in the previous section we designed a "toolbar" that had two states: expanded and collapsed. When we clicked on the toolbar
    it toggled between its two states by simply redrawing itself large or small. Such an instantaneous change can be jolting, but we can do
    better by giving the user a visual cue as to what's actually going on. If the toolbar were to 
    %em
      gradually 
    change its size from small to large, suddenly it becomes ridiculously obvious how the toolbar works.
  %p
    = partial 'padawan/transition_example'
  %p
    Notice the &lt;s:Transitions/&gt; block. Here we define what should happen when changing from any one state to another. We can also define
    what should happen between all states by writing
    %code
      fromState="*" toState="*"
    instead of   
    %code
      fromState="collapsed" toState="expanded"
    and eliminating the second transition altogether. Inside the transition we can define any set of effects we want including 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/effects/Sequence.html?allClasses=1", :title => "Flex Sequence Composite Effect" }
      effects that should happen in order
    and
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/effects/Parallel.html?allClasses=1", :title => "Flex Parallel Composite Effect" }
      effect that should happen in parallel
    and injecting
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/effects/Pause.html?allClasses=1", :title => "Flex Pause Effect" }
      pauses between effects,
    etc.
  %p
    Speaking of effects...
%h3
  %a{ :name => "effect" }
    What is an effect?
.definition
  %p
    A Flex Effect is a special type of non-visual object that knows how to animate a certain set of properties on a separate visual object. There
    are a variety of built-in effects for standard things like 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/Fade.html?allClasses=1", :title => "Spark Fade Effect" }
      fades,
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/Rotate3D.html?allClasses=1", :title => "Spark Rotate3D Effect" }
      3D rotations
    and
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/Wipe.html?allClasses=1", :title => "Spark Wipe Effect" }
      wipes,
    but the framework also gives you lower level control to create dazzling new effects to your heart's desire via classes like
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/Animate.html?allClasses=1", :title => "Spark Animate Effect" }
      spark.effects.Animate
    and
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/AnimateColor.html?allClasses=1", :title => "Spark AnimateColor Effect" }
      spark.effects.AnimateColor.
  %p
    There are (almost too) many ways to use and trigger effects, here are the most common in ActionScript 3:
    = partial 'padawan/effect_example_actionscript'
    and in MXML:
    = partial 'padawan/effect_example_mxml'
  %p
    The key parts of any effect definition are the 
    %code
      target/targets
    ,
    %code
      [property]From/[property]To
    and
    %code
      duration
    properties because these specify the Who, What and How Long of the effect. Additionally, you can use the 
    %code
      easer
    property to modify the How (make the effect bouncy, etc.), and if you can master that your 99% of the way to becoming an effects Jedi. 
  %p
    %strong
      The More You Know: 
  %p  
    Keep in mind that it's easy to over use  effects and a little animation goes a long way: pay particular attention to the durations when designing. 
    Also, stay away from anything in the mx.effects.* package if you possibly can because these were superseded in Flex 4 by the spark.effects.* 
    package where lives all your animation treats.
    
%h3
  %a{ :name => "event" }
    What is an event/event handler?
.definition
  %p
    Ok, this one is fairly intuitive and probably means exactly what you think it does youngling... except it's a little more complicated than that.
  %p
    An event in AS3/Flex is an object that represents something which happened, whether it's the application loading or a user typing into
    a text input. There are different classes for different events which contain information specific to that particular type of event and the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/", :title => "AS3/Flex API documentation"}
      API docs
    do a great job of letting you know which events are "dispatched" or come from the different classes you want to work with.
  %p
    %em
      All 
    events in AS3/Flex extend from the 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1", :title => "Flash Event base class" }
      flash.events.Event 
    base class and so you can always be guaranteed to have access to a few standard properties, the most important of which are:
    %ul
      %li
        %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#type", :title => "Flash Event type property"}
          \.type
        A String that identifies what action this event represents, like "click" or "uploadComplete". These types are typically constants defined in the
        event subclass you are interested in.
      %li
        %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#target", :title => "Flash Event target property"}
          \.target
        The object that originally dispatched the event, like a button or a timer
      %li
        %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#currentTarget", :title => "Flash Event currentTarget property"}
          \.currentTarget
        The object that is currently handling the event, i.e. the object that you registered your event listener on. What is an event listener?
  %p
    Good question. But first, you should know about event phases and the Display List. Pay attention because the evil forces of darkness 
    (i.e. interviewers) have been known to destroy many a padawan's hopes and dreams with questions like this.
  %p
    %strong
      Display List
  %p
    All visual objects ( e.g. 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#currentTarget", :title => "Flex 4 Group container" }
      Groups,
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/RichEditableText.html?allClasses=1", :title => "Flex 4 RichEditableText component" }
      RichEditableTexts
    ) spend most of their time as part of a tree of other visual objects that in Flash is called the Display List. At the root of the Display List is
    the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/display/Stage.html?allClasses=1", :title => "The Flash Stage" }
      Stage.
    Your Flex
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/Application.html?allClasses=1", :title => "Spark Application documentation" }
      Application
    class is the first 
    %em
      child 
    of the Stage, and the Stage is your Application's 
    %em
      parent.
    The rest of your visual objects flow down and fill out the tree from here.
  %p
    Flex actually has at least two "display lists", one for normal visual objects and one for pop-ups created by the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/managers/PopUpManager.html?allClasses=1", :title => "Flex Pop-up Manager"}
      PopUpManager.
    You'll normally only deal with the former, though, because as you design your application and add and remove visual elements, they are added and removed to
    this first display list, have parents and if they are containers may have children themselves.
  %p
    %strong
      Event Phases
  %p
    There are three, and they start at the root of the tree/Display List.
    %ul
      %li
        %em
          capture
        In this phase the event object is traveling down from the Stage through your Application to the target (you remember the event target right?),
        for example, a button the user clicked on.
      %li
        %em
          at-target
        In this phase the event object has actually arrived at the target and the target is given a chance to process the event.
      %li
        %em
          bubbling
        Arguably the most interesting phase, the event starts traveling back up the Display List from the target all the way
        back to the Stage. This is the point at which most event listeners get triggered.
    There are more idiosyncrasies to Flash events, like 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#preventDefault()", :title => "Canceling an event: preventDefault()" }
      cancelling
    and
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#stopPropagation()", :title => "Stopping propogation of an event" }
      stopping propogation
    and you can actually check the current phase of an event via the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html#eventPhase", :title => "Event eventPhase property" }
      \.eventPhase
    property. It is even possible to dispatch and catch events outside of the Display List, but if you've understood this so far, you're doing well.
  %p
    %em
      Check out 
      %a{ :href => "http://www.macrolearn.com/devnet/flash/quickstart/display_list_programming_as3/", :title => "Display List Programming" }
        this article 
      for more information on the Flash Display List. And 
      %a{ :href => "http://www.adobe.com/devnet/actionscript/articles/event_handling_as3_03.html", :title => "Flash Event Phases" }
        this article
      for more information on event phases.
  %p
    %strong
      So, finally, how does this relate to event listeners?
  %p
    An event listener is a function that takes an event object as its only parameter and is executed when the event it's listening for arrives 
    at the object it cares about. Remember that an event has a
    %code
      target
    and a
    %code
      currentTarget
    property? While a user may be clicking on a button (and thus the button becomes the event's target), you can actually register an event listener
    anywhere above that button in the Display List and your listener will be called during that click event's bubbling phase. 
  %p
    Let's say you put your
    button inside of a Group and register your "click" event listener on the Group. When your listener is executed the event's target will be
    the button 
    %em
      but 
    the currentTarget will be the Group, because the Group is now the object that is currently processing the event.
  %p
    %em
      *Phew*
    The reason you should know this is so you don't get confused and use target where you should use currentTarget and vice versa in your listeners.
    In Flex, when dealing with things like 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/List.html?allClasses=1", :title => "Flex 4 List Component" }
      Lists
    especially, but really any sort of container this is an important distinction to keep in mind.
  %p
    %strong
      Examples!
  %p
    Adding an event listener in ActionScript 3 (line 18 is the key here):
    = partial 'padawan/event_listener_example_as3'
  %p
    Wiring an event listener in MXML (it's on line 21):
    = partial 'padawan/event_listener_example_mxml'
  %p
    Bonus! Event phases in action:
    = partial 'padawan/event_phases_example'
    
%h3
  %a{ :name => "binding" }
    What is a binding?
.definition
  %p
    Flex bindings are a simple yet powerful way to link the value of two variables together. 
  %p
    Let's say you're keeping track of the score of
    the current person who is playing your awesome Flex game somewhere in a variable. If you wanted to display this score in your UI via a 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/Label.html?allClasses=1", :title => "Flex 4 Label component" }
      Label
    you'd need to set the
    %code
      \.text
    property on the Label to the score, but you don't necessarily want that Label's 
    %code
      \.text
    property to be the only place you store the score and you'd like the Label to automatically update itself every time the score changes. 
    You can do this very cleanly and succinctly using Flex bindings.
  %p
    When you use the binding syntax in MXML, the Flex compiler will automatically generate and inject code that will propagate the value from the
    binding 
    %em
      source 
    to the binding
    %em
      destination
    (in this case your variable to the Label's text property) into your Application when you compile it to a SWF. This does add a little size
    to your application and a large amount of bindings can have performance implications, but generally speaking this is the best way
    to set up a binding because in that generated code are some checks and balances for handling edge cases that you'd have to manually
    write otherwise.
  %p
    Here's a one-way binding in MXML:
    = partial 'padawan/binding_example_one_way_mxml'
  %p
    In Flex 4, you can also easily create two-way bindings in MXML:
    = partial 'padawan/binding_example_two_way_mxml'
  %p
    one way as3 example
  %p
    avoiding warnings with the [Bindable] tag, can bind props/gttrs+sttrs or gttrs with a custom [Bindable("eventName")] property
    Yes, bindings are based on events that trigger event handlers which actually update the values. For any built-in Flex components
    the API Docs will tell you what event triggers a binding for a given bindable property or method although generally speaking
    you don't need to care.
%h3
  %a{ :name => "trace" }
    What is trace()?
.definition
  %p
    %code
      trace() 
    is a top-level utility function that lets you output strings to the console (typically inside your IDE) when running the debug version of your application.
  %p
    There are much more efficient ways to debug your application such as using the visual debugger built into  
    %a{ :href => "#flashbuilder", :title => "Adobe Flash Builder" }
      Flash Builder
    or using
    %a{ :href => "http://code.google.com/p/flash-thunderbolt/wiki/ThunderBoltAS3", :title => "Logging for Firebug/Firefox" }
      ThunderBoltAS3
    to output to the log in Firebug/Firefox, but it's the equivalent to 
    %code
      System.out.println 
    in Java or 
    %code
      puts
    in Ruby and so is a simple yet essential tool in your Jedi belt.
  %p
    It works just like you think:
    = partial 'padawan/trace_example'
  %p
    Note that all objects have a built-in 
    %code
      toString()
    method (which you override without the keyword
    %code
      override
    in your custom classes because it's a vestige of prototype-based inheritance) and is called on the target object when you pass it to 
    %code
      trace()
    \. A Class's default 
    %code
      toString() 
    sometimes gives you really useful information and sometimes completely sucks, but you can always try it because you can always pass anything directly into the 
    %code
      trace()
    function.
%h3
  %a{ :name => "racetrack" }
    Bonus: What is the elastic racetrack?  
.definition
  %p
    Flash Player executes your code in cycles that are divided into two main parts: drawing and calculating. Your goal as a Flex developer is
    not only to write code that results in faster cycles overall, but also to write code that achieves a balance between the time the Flash Player 
    spends calculating and rendering. So, if you're drawing a chinaman walking across the screen 100 times per second, but the screen can only refresh
    at 60 times per second, then you are wasting time that could be spent doing other things by drawing the chinaman 40 extra times per second.
  %p
    The best way to ensure that your racetrack stays balanced is to take advantage of the hooks that the Flex framework gives you. Overriding methods like 
    commitProperties(), measure() and updateDisplayList() will let you customize your components as much as you want, but still allow the Flex framework
    to decide when is the optimal time to perform each of these duties. Duties. haha
  %p
    Check out
    %a{ :href => "http://www.craftymind.com/2008/04/18/updated-elastic-racetrack-for-flash-9-and-avm2/", :title => "Updated 'Elastic Racetrack' for Flash 9 and AVM2" }
      this article
    for more details.
%p
  Did I miss something? Leave a comment with your concept and explanation and if it makes sense I'll pull it in like Obi-wan.