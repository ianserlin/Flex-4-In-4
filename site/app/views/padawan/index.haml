.menu
  .title
    Know Your Stuff
    /
      = I18n.t("padawan_menu_title")
  %ul
    %li
      %a{ :href => "#flex" }
        What is Adobe Flex?
    %li
      %a{ :href => "#flashbuilder" }
        What is Adobe Flash Builder/Flex Builder?
    %li
      %a{ :href => "#as3" }
        What is ActionScript 3 (AS3)?
    %li
      %a{ :href => "#mxml" }
        What is MXML?
    %li
      %a{ :href => "#swf" }
        What is a SWF?
    %li
      %a{ :href => "#swc" }
        What is a SWC?
    %li
      %a{ :href => "#swz" }
        What is a SWZ?        
    %li
      %a{ :href => "#project" }
        What is a Flex Project?
    %li
      %a{ :href => "#libraryproject" }
        What is a Flex Library Project?
    %li
      %a{ :href => "#app" }
        What is an Application?
    %li
      %a{ :href => "#componentcontainer" }
        What is a component and what is container?
    %li
      %a{ :href => "#layout" }
        What is a layout?
    %li
      %a{ :href => "#skin" }
        What is a skin?
    %li
      %a{ :href => "#css" }
        What is a style and what is Flex CSS?
    %li
      %a{ :href => "#state" }
        What is a State?
    %li
      %a{ :href => "#transition" }
        What is a Transition?
    %li
      %a{ :href => "#effect" }
        What is an effect?
    %li
      %a{ :href => "#event" }
        What is an event/event handler?
    %li
      %a{ :href => "#binding" }
        What is a binding?
    %li
      %a{ :href => "#trace" }
        What is trace()?
    %li
      %a{ :href => "#racetrack" }
        Bonus: What is the elastic racetrack?

.notice
  .title
    Padawan Series
  %p
    The information here is designed to take you from ground zero to speaking the lingo.
    On this one page are the foundational concepts that all the other series build on and wrapping your
    mind around the following ideas first will allow you to go so much faster later on.
  %p
    Train well and become one with the Flex.

%h3
  %a{ :name => "flex" }
    What is Adobe Flex?
.definition
  %p
    The 
    %a{ :href => "", :title => "Adobe Flex SDK @ adobe.com" }
      Adobe Flex SDK 
    is a framework, a library of classes and components written in the
    %a{ :href => "#as3", :title => "What is ActionScript 3?"}
      ActionScript 3
    language that are provided to you so that you can build applications that run on the Adobe Flash
    platform more quickly and at a higher quality. The Flex SDK layers many ideas on top of the base
    Flash API, including a secondary, XML based language named
    %a{ :href => "#mxml", :title => "What is MXML?" }
      MXML.
  %p
    The Flex SDK is free, open source and the gold standard for creating any kind of mildly complex
    application that runs in Flash. The most recent major revision of the SDK if Flex 4, which is what
    this site is all about. Yay learning!


%h3
  %a{ :name => "flashbuilder" }
    What is Adobe Flash Builder/Flex Builder?
.definition
  %p
    %a{ :href => "", :title => "Adobe Flash Builder 4 @ adobe.com" }
      Flash Builder 4
    is the latest version of Adobe's custom IDE for creating 
    %a{ :href => "#as3", :title => "What is ActionScript 3?"}
      ActionScript 3
    and Flex-based applications.
    It's based on 
    %a{ :href => "", :title => "The Eclipse IDE" }
      Eclipse 
    and you can install it as a standalone application or as a plug-in for an existing Eclipse installation.
    Unfortunately, it is not free, but is extremely useful and relatively easy to work with. It includes a built-in
    visual debugger, network monitoring, an application and memory profiler and, of course, auto-complete.
  %p
    However, there are other graphical IDEs for developing Flex applications like
    %a{ :href => "", :title => "The Free, Open-Source FDT Flex/AS3 IDE" }
      FDT
    and
    %a{ :href => "", :title => "" }
      IntelliJ
    as well as custom solutions for independent editors like
    %a{ :href => "http://textmate.com", :title => "The Infamous TextMate editor for OS X" }
      TextMate
    based on the free Flex compiler (mxmlc) and you should try them all and use the tool that suits you best.
  %p
    For the release of Flex 4, Flash Builder was rebranded as such instead of being called Flex Builder as it was in previous
    versions. This was done to clear up confusion related to the similar naming between the free Flex SDK and the for-profit Builder IDE.
    
    
%h3
  %a{ :name => "as3" }
    What is ActionScript 3 (AS3)?
.definition
  %p
    Strongly-typed, object-oriented mix between Java and JavaScript with its own set of built-in classes and utilities.    
    
    
%h3
  %a{ :name => "mxml" }
    What is MXML?
.definition
  %p
    MXML is a markup language in that is based on well-formed XML and is mostly used to design the visual look and feel of a Flex
    application and is contained in files that have an .mxml extension. Pretend for a second that HTML was one with the force, 
    perhaps in a year or two you would call it HTML5, but for now at least it's name is MXML and it's a pretty hand shorthand 
    for creating components quickly and that are easy to read.
  %p
    Even though the visual components that are built-in to the Flex SDK are written in ActionScript 3 and you can do everything you
    can in MXML in ActionScript 3 and when you create any kind of sophisticated application you will write some part of it 
    (maybe most of it) in ActionScript 3, you will most likely be writing a lot of MXML. This is what it looks like:
    = partial 'padawan/mxml_example'
  %p
    Let's take this line by line.
    %ul.spaced
      %li
        .heading
          Creating the
          %a{ :href => "#application", :title => "What is an Application?" }
            Application
          \: Line 2
        This is the top-most container in any Flex application and should be in the first file that gets loaded. All MXML files
        will have an outer-most class declaration at the top.
      %li
        .heading
          XML namespaces: Lines 2-4
        Like all good XML files, tags in MXML are namespaced - in particular the
        %code
          mx
        namespace refers to Flex 3/Halo components (which you should use as little as possible) and the
        %code
          s
        namespace refers to those classes that were introduced in Flex 4/Gumbo/Spark.
      %li
        .heading
          Inline event handlers: Line 5
        Almost all visual components in Flex dispatch some variety of 
        %a{ :href => "#event", :title => "What is an event/event dispatcher?"}
          events. 
        In MXML you can use this inline syntax
        to specify a function to call when the event occurs. Actually, you can also write inline ActionScript 3 here instead
        but that's frowned upon the same way that inline JavaScript is in HTML because it's not as reusable and not
        as maintainable.
      %li
        .heading
          Inline effect triggers: Line 6
        Almost all visual components in Flex also support some variety of 
        %a{ :href => "#effect", :title => "What is an effect?" }
          effects
        that are triggered by certain things that happen to the component, such as the
        %code
          showEffect
        when the component's visibility property changes from 
        %code
          false to 
        %code
          true, 
        the 
        %code
          resizeEffect
        when the component's size changes, or in this case the
        %code
          addedEffect
        when this component becomes the child of another component ( here the Application instance is becoming a child of the
        %a{ :href => "#displaylist", :title => "About the Stage and the Display List"}
          Stage
        ). You can bind the trigger you're interested in to an instance of a
        %code
          spark.effects.Effect
        subclass and that effect will have its
        %code
          play(...)
        method called passing in your component when the effect is triggered.
      %li
        .heading
          The Metadata block: Lines 8-10
        At various points in time you'll need to add metadata to your classes like when you're creating custom
        %a{ :href => "#skin", :title => "What is a skin?" }
          skins
        or simply specifying that your component dispatches custom events. In ActionScript 3 you add these metadata
        tags immediately preceding the class declaration, suffice it to say for now that the
        %code
          fx:Metadata
        block is where you stick these things in MXML.
      %li
        .heading
          Inline ActionScript 3: Lines 12-24
        Oh yes, you can embed AS3 directly in an MXML class by sticking in an
        %code
          fx:Script
        block similar to how you would add a 
        %code
          <script type="text/javascript">...your code...</script>
        block in an HTML page. You can do anything you can in a
        %code
          \.as
        file and this can be extremely convenient, but again, for anything mildly complex you probably want to
        pull that code out into a separate ActionScript 3 file to keep your code clean and simple.
      %li
        .heading
          Inline Declarations: Lines 26-29
        While you can add any visual component as a direct child of a
        %a{ :href => "#componentcontainer", :title => "What is a container?" }
          container
        (like Application, Group, Panel, etc.) in MXML, any
        %em
          non-visual elements
        must be contained within an
        %code
          fx:Declarations
        block. In this case, we're defining an instance of the 
        %a{ :href => "", :title => "Flex 4 Fade Effect"}
          Fade
        effect which acts on visual components but is not itself a visual component, and an instance of a 
        %code
          String.
        Most of the time you probably won't want to declare value objects (like Strings, Arrays, etc.) in MXML,
        instead preferring to stick them in the 
        %code
          fx:Script
        block, but it's nice to know you can if you need to.
      %li
        .heading
          Setting properties via MXML tags: Lines 31-33
        This 
        %code
          s:layout
        tag actually belongs to the 
        %code
          s:Application
        instance and what we put inside the tag gets assigned to the Application's .layout property. There
        are a few cases where this particular syntax is convenient because it's easier to express what you want
        in MXML tags, e.g. when you're creating a new instance of a class whose constructor doesn't take any arguments.
        There are also some properties which are almost always set using this syntax by convention, like layouts.
        You can use
        %a{ :href => "#binding", :title => "What is a binding?" }
          binding
        syntax here.
      %li
        .heading{ :style => "font-size: 14px;"}
          Adding child components: Line 35
        The bread and the butter - grouping and arranging the unique set of controls that your users will interact with is 
        the main strength of MXML and probably the most common thing you'll use it for. Here we're creating a new instance of the
        %a{ :href => "", :title => "Flex 4 Label Component" }
          Label 
        class with its
        %code
          id
        property initialized to "theLabel" and its
        %code
          text
        property initialized to "Mufasa!". This label instance then becomes a direct child of and is owned and positioned by the Application container. 
    %p
      Holy Yoda - that was a lot of information to throw at you - just keep in mind that MXML files can be a nice way to make a lot of things
      happen with a little bit of code and come back and use this section as a reference if you need to.
      
      
%h3
  %a{ :name => "swf" }
    What is a SWF?
.definition
  %p
    SWF files are the compiled version of your 
    %a{ :href => "#project", :title => "What is a Flex Project?"}
      Flex
    or ActionScript Project, like an .exe on Windows or .app on Mac except that they are cross-platform. Inside is an intermediary 
    byte-code that is interpreted  and executed by the Flash Player runtime. While you can run SWFs independently in a browser or 
    from your desktop, they are typically embedded into web pages using the 
    %code
      &lt;object/&gt;
    and
    %code
      &lt;embed/&gt;
    tags or via JavaScript using something like
    %a{ :href => "http://code.google.com/p/swfobject/", :title => "SWFObject JavaScript library" }
      SWFObject
    which is the gold standard way of embedding SWFs that bakes in Flash Player version checking and upgrading.
    
    
%h3
  %a{ :name => "swc" }
    What is a SWC?
.definition
  %p
    SWCs are compiled versions of your 
    %a{ :href => "#libraryproject", :title => "What is a Flex Library Project?"}
      Flex Library
    projects. These typically contain 3rd party libraries of classes, utilities and components that you can link in and use
    in your Flex projects. SWCs are just a more compact way of reusing functionality than including a bunch of extra source
    code in your 
    %a{ :href => "#app", :title => "What is an Application?" }
      application 
    that you don't need to modify yourself. If your familiar with Java, SWCs are the equivalent of library jars.
    
    
%h3
  %a{ :name => "swz" }
    What is a SWZ?
.definition
  %p
    SWZs are the same as SWCs except that they are officially "signed" by a certifier, such as Adobe, to be authentic
    and unadulterated. You probably won't be creating any SWZs yourself, but you might see them most notably as packaged
    versions of the Flex SDK and related Adobe libraries if you're using
    %a{ :href => "http://livedocs.adobe.com/flex/3/html/help.html?content=rsl_09.html", :title => "Flex Runtime Shared Loading explanation" }
      RSL linking
    in your projects.
    
    
%h3
  %a{ :name => "project" }
    What is a Flex Project?
.definition
  %img.right{ :src => "/images/project_example.png", :alt => "Flex Project Directory Structure" }
  A Flex Project is simply a collection of files and folders that make up the Flex application you are creating. In a Flex Project, only
  those classes and assets that are actually used (including those you linked in from SWCs depending on your compiler settings)
  will be compiled into the final SWF output file, unlike
  %a{ :href => "#libraryproject", :title => "What is a Flex Library Project?" }
    Flex Library Projects
  \.
  The typical directory structure includes:
  %ul.spaced
    %li
      .heading
        %code
          src
        folder 
      where you'll put all your custom
      %a{ :href => "#mxml", :title => "What is MXML?" }
        MXML
      and
      %a{ :href => "#as3", :title => "What is ActionScript 3?" }
        AS3
      files, organized (hopefully) into packages.
    %li
      .heading
        %code
          Flex
        framework folder
      which is usually just a dynamically linked version of Flex Framework 
      %a{ :href => "#swc", :title => "What is a SWC?" }
        SWCs
      \.
    %li
      .heading
        %code
          bin-debug
        folder        
      where you'll find the debug (development) version of your compiled application after the first time it's built.
    %li
      .heading
        %code
          bin-release
        folder        
      where you'll find a much smaller release (production) version of your compiled application when you do a release-build from Flash Builder.
    %li
      .heading
        %code
          html-template
        folder        
      which contains any files you want to be included in your debug and release builds and thus interpreted and placed into the bin-debug
      and bin-release folders, respectively. This includes the HTML page that you want to develop your application in by default and is pre-populated
      by Flash Builder when you create a new Flex Project. Note that the 
      %code
        index.template.html
      file gets turned into the
      %code
        [your_app_name].html
      file in the
      %code
        bin-release
      and
      %code
        bin-debug
      folders, in this case
      %code
        EventPhasesApp.html
      \.
    %li
      .heading
        %code
          libs
        folder        
      where you'll typically put any
      %a{ :href => "#swc", :title => "What is a SWC?" }
        SWC
      files that containing extra classes and/or assets you want to use in your application.
  %p
    Don't forget to pick a testing framework like FlexUnit and add a 
    %code
      test
    folder for your tests!
  .clear
  
  
%h3
  %a{ :name => "libraryproject" }
    What is a Flex Library Project?
.definition
  %img.right{ :src => "/images/library_project_example.png", :alt => "Flex Library Project Directory Structure" }    
  A Flex Library Project is simply a collection of independent files and folders that you want to compile into a 
  %a{ :href => "#swc", :title => "What is a SWC?" }
    SWC
  for use in other projects. Unlike regular
  %a{ :href => "#project", :title => "What is a Flex Project?" }
    Flex Projects
  which only include classes that are actually used in the output SWF, by default Flex Library Projects will include
  all classes in all its source folders into the compiled SWC.
  The typical directory structure includes:
  %ul.spaced
    %li
      .heading
        %code
          src
        folder 
      where you'll put all your custom
      %a{ :href => "#mxml", :title => "What is MXML?" }
        MXML
      and
      %a{ :href => "#as3", :title => "What is ActionScript 3?" }
        AS3
      files, organized (hopefully) into packages.
    %li
      .heading
        %code
          Flex
        framework folder
      which is usually just a dynamically linked version of Flex Framework 
      %a{ :href => "#swc", :title => "What is a SWC?" }
        SWCs
      \.
    %li
      .heading
        %code
          bin
        folder        
      where the compiled SWC version of all your classes will output to by default.
  .clear
  
  
%h3
  %a{ :name => "app" }
    What is an Application?
.definition
  %p
    All Flex 4 apps use the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/Application.html?allClasses=1", :title => "Spark Application API" }
      Spark Application
    class as their entry point, like the
    %code
      main(...)
    function in C++/Java. When you create a new
    %a{ :href => "#project", :title => "What is a Flex Project?" }
      Flex Project
    a
    %em
      [YourAppName].mxml 
    file is generated for you in the default package. This is where you will always add your first lines of code that kick off
    the rest of your app or wire in things like preloaders. The Flash Builder generated Application class looks like this:
    = partial 'padawan/blank_application_example'
  %p
    
%h3
  %a{ :name => "componentcontainer" }
    What is a component and what is a container?
.definition
  %p
    The line that separates containers and components is conceptual as well as practical. Built-in components are things like
    Button, TextInput, RichEditableText, VideoPlayer, etc. and typically extend the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/supportClasses/SkinnableComponent.html?allClasses=1", :title => "Flex 4 SkinnableComponent API" }
      SkinnableComponent
    class if they can be 
    %a{ :href => "#skin", :title => "What is a skin?" }
      skinned. 
    Built-in containers are things like Application, Group, Panel, etc. and typically extend
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/SkinnableContainer.html?allClasses=1", :title => "Flex 4 SkinnableContainer API" }
      SkinnableContainer
    or 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/SkinnableDataContainer.html?allClasses=1", :title => "Flex 4 SkinnableDataContainer API" }
      SkinnableDataContainer
    if they can be skinned.
  %p
    Conceptually though, a component is a class that may contain multiple sub-controls like a button and a text input, but is thought of and can
    be used as if it is one single, cohesive control. This is in contrast to a container, which is designed with the express purpose of being able
    to contain and layout a dynamic number of anonymous child controls. While a component might contain some logic to manipulate its sub-controls,
    e.g. only enabling its button child when its text input child has text in it, a container should not care about what class any of its children
    are and shouldn't normally contain any special logic to manipulate its children, it is simply a bucket to group visual elements together.
  %p
    The public properties and methods that a component exposes are highly dependent on the purpose of the control. Conversely, good container 
    design by convention means exposing a 
    %code
      contentGroup
    property that will be populated with the dynamic children the container is managing
    and a
    %code
      layout
    property that can take a
    %a{ :href => "#layout", :title => "What is a layout?" }
      Layout
    instance that manages how its dynamic children are arranged on screen.
  %p
    Practically, in 
    %a{ :href => "#mxml", :title => "What is MXML?" }
      MXML
    you can nest additional visual elements inside of a container but cannot nest any additional visual elements inside a component.
    So, when you're designing your custom controls decide whether your new control should be thought of as one cohesive control or is 
    designed to hold a variety of other controls and choose your base class appropriately.

%h3
  %a{ :name => "layout" }
    What is a layout?
.definition
  %p
    Layouts are an awesome new addition in Flex 4 and they let you further separate the code that defines what components
    are part of your application with the code that positions those components on the screen. This means you can define your
    own custom way for arranging components and easily test it and reuse it many times without having to duplicate code.
  %p
    Flex 4 ships with a few of the most common types of layouts you'll want to use built-in, namely:
    %ul.spaced
      %li
        .title
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/layouts/BasicLayout.html?allClasses=1", :title => "Flex 4 BasicLayout API" }
            Basic Layout 
          (absolute positioning)
        %p
          If you give a
          %a{ :href => "#componentcontainer", :title => "What is a container?" }
            container
          a basic layout, its child components specify their requested positions using the
          %code
            top, bottom, left, right, verticalCenter, horizontalCenter
          and
          %code
            x
          and
          %code
            y
          properties as in the following example:
        %p
          = partial 'padawan/basic_layout_example'
        %p
          You can mix and match these properties in any combination you want to specify where your components will appear on screen.
      %li
        .title
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/layouts/VerticalLayout.html?allClasses=1", :title => "Flex 4 VerticalLayout API" }
            Vertical 
          and 
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/layouts/HorizontalLayout.html?allClasses=1", :title => "Flex 4 HorizontalLayout API" }
            Horizontal 
          Layouts (relative positioning)
        %p
          The HorizontalLayout and VerticalLayout intuitively do what you think they do, simply arrange their child components in order
          horizontally or vertically, but you can use the
          %code
            gap
          (the number of pixels between successive components), 
          %code
            horizontalAlign
          and
          %code
            verticalAlign
          properties of these layouts to modify the way they do it (Lines 11-13 &amp; 34):
        %p
          = partial 'padawan/horizontal_and_vertical_layout_example'
        %p
          Note that the 
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/HGroup.html?allClasses=1", :title => "Flex 4 HGroup Container" }
            HGroup
          and
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/VGroup.html?allClasses=1", :title => "Flex 4 HGroup Container" }
            VGroup
          containers are simply shortcut ways of specifying a Group with a horizontal or vertical layout, respectively, and in that case
          you simply specify the layout properties directly on the HGroup or VGroup itself.
      %li
        .title
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/layouts/TileLayout.html?allClasses=1", :title => "Flex 4 TileLayout API" }
            Tile Layout
        %p
          TileLayout is used primarily with 
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/List.html?allClasses=1", :title => "Flex 4 List Component" }
            List
          and
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/DataGroup.html?allClasses=1", :title => "Flex 4 DataGroup Component" }
            DataGroup
          \-based components to organize the display of data-driven visual elements (like a list of orders) as opposed to buttons and controls. All classes that extend
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/layouts/supportClasses/LayoutBase.html", :title => "Flex 4 LayoutBase Component" }
            LayoutBase
          , however, are interchangeable, meaning you can use TileLayout outside of List controls as demonstrated by simply modifying the previous example:
        %p
          = partial 'padawan/tilelayout_example'
        %p
          The first thing you'll notice is that by default TileLayout sets the size of all the items it is laying out (its tiles) to be the same. 
          Since TileLayouts arrange components both horizontally and vertically they expose a variety of different properties to give you finer
          grained control on how the "tiles" are arranged without having to do all then fancy math yourself. You'll really need to read the
          %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/layouts/TileLayout.html?allClasses=1", :title => "Flex 4 TileLayout API" }
            documentation 
          and play in order to get a true feel for what it's capable of though, in particular check out
          %code
            columnAlign, rowAlign, columnWidth, rowHeight, orientation
          and
          %code
            orientation
          \.
        
%h3
  %a{ :name => "skin" }
    What is a skin?
  
%h3
  %a{ :name => "css" }
    What is a style and what is Flex CSS?


%h3
  %a{ :name => "state" }
    What is a State?
.definition
  %p
    Flex States are kind of similar to a CSS class, but way more powerful. Whereas in a CSS class you can change things like colors, font sizes, etc., 
    using a Flex State you can change 
    %em
      any 
    property on a component, which functions get called for events like click 
    and even which parts of the component are currently visible or not simply by switching the component's state.
  %p
    For instance, let's say you're making a toolbar component. It might have a "normal" state where it's size is 300px by 40px, but in the "expanded"
    state, its size should increase to maybe 350px by 400px. You can easily achieve this using just one component by specifying the two states in the
    following way:
  %p
    = partial 'padawan/state_example'
  %p
    Note the &lt;s:states/&gt; block where the two States for the toolbar are defined, the use of the [property].[state] syntax on the properties of the BorderContainer
    and the includeIn/exludeFrom directives on the two buttons. Also note that the default state of the component is the first one you define.
    If you get this, you now know 95% of what you need to know about Flex States.
  
  
%h3
  %a{ :name => "transition" }
    What is a Transition?
.definition
  %p
    Transitions and States go hand in hand. While a State defines how a component looks and behaves at any given point in time, the Transition
    specifies how a component gets from one state to another and can add a level of finesse to your application.
  %p
    For example, in the previous section we designed a "toolbar" that had two states: expanded and collapsed. When we clicked on the toolbar
    it toggled between its two states by simply redrawing itself large or small. Such an instantaneous change can be jolting, but we can do
    better by giving the user a visual cue as to what's actually going on. If the toolbar were to 
    %em
      gradually 
    change its size from small to large, suddenly it becomes ridiculously obvious how the toolbar works.
  %p
    = partial 'padawan/transition_example'
  %p
    Notice the &lt;s:Transitions/&gt; block. Here we define what should happen when changing from any one state to another. We can also define
    what should happen between all states by writing
    %code
      fromState="*" toState="*"
    instead of   
    %code
      fromState="collapsed" toState="expanded"
    and eliminating the second transition altogether. Inside the transition we can define any set of effects we want including 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/effects/Sequence.html?allClasses=1", :title => "Flex Sequence Composite Effect" }
      effects that should happen in order
    and
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/effects/Parallel.html?allClasses=1", :title => "Flex Parallel Composite Effect" }
      effect that should happen in parallel
    and injecting
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/effects/Pause.html?allClasses=1", :title => "Flex Pause Effect" }
      pauses between effects,
    etc.
  %p
    Speaking of effects...
%h3
  %a{ :name => "effect" }
    What is an effect?
.definition
  %p
    A Flex Effect is a special type of non-visual object that knows how to animate a certain set of properties on a separate visual object. There
    are a variety of built-in effects for standard things like 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/Fade.html?allClasses=1", :title => "Spark Fade Effect" }
      fades,
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/Rotate3D.html?allClasses=1", :title => "Spark Rotate3D Effect" }
      3D rotations
    and
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/Wipe.html?allClasses=1", :title => "Spark Wipe Effect" }
      wipes,
    but the framework also gives you lower level control to create dazzling new effects to your heart's desire via classes like
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/Animate.html?allClasses=1", :title => "Spark Animate Effect" }
      spark.effects.Animate
    and
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/effects/AnimateColor.html?allClasses=1", :title => "Spark AnimateColor Effect" }
      spark.effects.AnimateColor.
  %p
    There are (almost too) many ways to use and trigger effects, here are the most common in ActionScript 3:
    = partial 'padawan/effect_example_actionscript'
    and in MXML:
    = partial 'padawan/effect_example_mxml'
  %p
    The key parts of any effect definition are the 
    %code
      target/targets
    ,
    %code
      [property]From/[property]To
    and
    %code
      duration
    properties because these specify the Who, What and How Long of the effect. Additionally, you can use the 
    %code
      easer
    property to modify the How (make the effect bouncy, etc.), and if you can master that your 99% of the way to becoming an effects Jedi. 
  %p
    %strong
      The More You Know: 
  %p  
    Keep in mind that it's easy to over use effects and a little animation goes a long way: pay particular attention to the durations when designing. 
    Also, stay away from anything in the mx.effects.* package if you possibly can because these were superseded in Flex 4 by the spark.effects.* 
    package where lives all your animation treats.
    
%h3
  %a{ :name => "event" }
    What is an event/event handler?
.definition
  %p
    Ok, this one is fairly intuitive and probably means exactly what you think it does youngling... except it's a little more complicated than that.
  %p
    An event in AS3/Flex is an object that represents something which happened, whether it's the application loading or a user typing into
    a text input. There are different classes for different events which contain information specific to that particular type of event and the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/", :title => "AS3/Flex API documentation"}
      API docs
    do a great job of letting you know which events are "dispatched" or come from the different classes you want to work with.
  %p
    %em
      All 
    events in AS3/Flex extend from the 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1", :title => "Flash Event base class" }
      flash.events.Event 
    base class and so you can always be guaranteed to have access to a few standard properties, the most important of which are:
    %ul
      %li
        %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#type", :title => "Flash Event type property"}
          \.type
        A String that identifies what action this event represents, like "click" or "uploadComplete". These types are typically constants defined in the
        event subclass you are interested in.
      %li
        %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#target", :title => "Flash Event target property"}
          \.target
        The object that originally dispatched the event, like a button or a timer
      %li
        %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#currentTarget", :title => "Flash Event currentTarget property"}
          \.currentTarget
        The object that is currently handling the event, i.e. the object that you registered your event listener on. What is an event listener?
  %p
    Good question. But first, you should know about event phases and the Display List. Pay attention because the evil forces of darkness 
    (i.e. interviewers) have been known to destroy many a padawan's hopes and dreams with questions like this.
  %p
    %strong
      %a{ :name => "displaylist" }
        Display List
  %p
    All visual objects ( e.g. 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#currentTarget", :title => "Flex 4 Group container" }
      Groups,
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/RichEditableText.html?allClasses=1", :title => "Flex 4 RichEditableText component" }
      RichEditableTexts
    ) spend most of their time as part of a tree of other visual objects that in Flash is called the Display List. At the root of the Display List is
    the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/display/Stage.html?allClasses=1", :title => "The Flash Stage" }
      Stage.
    Your Flex
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/Application.html?allClasses=1", :title => "Spark Application documentation" }
      Application
    class is the first 
    %em
      child 
    of the Stage, and the Stage is your Application's 
    %em
      parent.
    The rest of your visual objects flow down and fill out the tree from here.
  %p
    Flex actually has at least two "display lists", one for normal visual objects and one for pop-ups created by the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/managers/PopUpManager.html?allClasses=1", :title => "Flex Pop-up Manager"}
      PopUpManager.
    You'll normally only deal with the former, though, because as you design your application and add and remove visual elements, they are added and removed to
    this first display list, have parents and if they are containers may have children themselves.
  %p
    %strong
      Event Phases
  %p
    There are three, and they start at the root of the tree/Display List.
    %ul
      %li
        %em
          capture
        In this phase the event object is traveling down from the Stage through your Application to the target (you remember the event target right?),
        for example, a button the user clicked on.
      %li
        %em
          at-target
        In this phase the event object has actually arrived at the target and the target is given a chance to process the event.
      %li
        %em
          bubbling
        Arguably the most interesting phase, the event starts traveling back up the Display List from the target all the way
        back to the Stage. This is the point at which most event listeners get triggered.
    There are more idiosyncrasies to Flash events, like 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#preventDefault()", :title => "Canceling an event: preventDefault()" }
      cancelling
    and
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html?allClasses=1#stopPropagation()", :title => "Stopping propogation of an event" }
      stopping propogation
    and you can actually check the current phase of an event via the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/flash/events/Event.html#eventPhase", :title => "Event eventPhase property" }
      \.eventPhase
    property. It is even possible to dispatch and catch events outside of the Display List, but if you've understood this so far, you're doing well.
  %p
    %em
      Check out 
      %a{ :href => "http://www.macrolearn.com/devnet/flash/quickstart/display_list_programming_as3/", :title => "Display List Programming" }
        this article 
      for more information on the Flash Display List. And 
      %a{ :href => "http://www.adobe.com/devnet/actionscript/articles/event_handling_as3_03.html", :title => "Flash Event Phases" }
        this article
      for more information on event phases.
  %p
    %strong
      So, finally, how does this relate to event listeners?
  %p
    An event listener is a function that takes an event object as its only parameter and is executed when the event it's listening for arrives 
    at the object it cares about. Remember that an event has a
    %code
      target
    and a
    %code
      currentTarget
    property? While a user may be clicking on a button (and thus the button becomes the event's target), you can actually register an event listener
    anywhere above that button in the Display List and your listener will be called during that click event's bubbling phase. 
  %p
    Let's say you put your
    button inside of a Group and register your "click" event listener on the Group. When your listener is executed the event's target will be
    the button 
    %em
      but 
    the currentTarget will be the Group, because the Group is now the object that is currently processing the event.
  %p
    %em
      *Phew*
    The reason you should know this is so you don't get confused and use target where you should use currentTarget and vice versa in your listeners.
    In Flex, when dealing with things like 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/List.html?allClasses=1", :title => "Flex 4 List Component" }
      Lists
    especially, but really any sort of container this is an important distinction to keep in mind.
  %p
    %strong
      Examples!
  %p
    Adding an event listener in ActionScript 3 (line 18 is the key here):
    = partial 'padawan/event_listener_example_as3'
  %p
    Wiring an event listener in MXML (it's on line 21):
    = partial 'padawan/event_listener_example_mxml'
  %p
    Bonus! Event phases in action:
    = partial 'padawan/event_phases_example'
    
%h3
  %a{ :name => "binding" }
    What is a binding?
.definition
  %p
    Flex bindings are a simple yet powerful way to link the value of two variables together. 
  %p
    Let's say you're keeping track of the score of
    the current person who is playing your awesome Flex game somewhere in a variable. If you wanted to display this score in your UI via a 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/components/Label.html?allClasses=1", :title => "Flex 4 Label component" }
      Label
    you'd need to set the
    %code
      \.text
    property on the Label to the score, but you don't necessarily want that Label's 
    %code
      \.text
    property to be the only place you store the score and you'd like the Label to automatically update itself every time the score changes. 
    You can do this very cleanly and succinctly using Flex bindings.
  %p
    When you use the binding syntax in MXML, the Flex compiler will automatically generate and inject code that will propagate the value from the
    binding 
    %em
      source 
    to the binding
    %em
      destination
    (in this case your variable to the Label's text property) into your Application when you compile it to a SWF. This does add a little size
    to your application and a large amount of bindings can have performance implications, but generally speaking this is the best way
    to set up a binding because in that generated code are some checks and balances for handling edge cases that you'd have to manually
    write otherwise.
  %p.title
    One-Way Bindings (MXML)
  %p
    Here's a one-way binding in MXML using the {} syntax:
    = partial 'padawan/binding_example_one_way_mxml'
  %p.title
    Two-Way Bindings (MXML)    
  %p
    In Flex 4, you can also easily create two-way bindings in MXML using the @{} syntax, which is especially useful when one of your
    variables is defined in AS3. In the next example the Label simply does a one way binding to display the value of the
    %code
      yourSentence
    variable while the TextInput actually allows you to 
    %em
      change 
    the value of
    %code
      yourSentence
    via two-way bindings:
    = partial 'padawan/binding_example_two_way_mxml'
  %p
    Note the 
    %code
      [Bindable] 
    metadata tag on the 
    %code
      runningTime 
    variable allows it to actually be bound and propagate its value. Behind the scenes,
    the Flex compiler is generating code for you again that basically wraps your variable in a getter/setter. If you omit the 
    %code
      [Bindable]
    tag you will get compile-time warnings in Flash Builder and anything attempting to bind to the variable will only ever get the variable's
    value once, when it first attempts to bind. You can have as many bindable things as you want in your classes and you can use the
    [Bindable] tag on properties, static properties, getter/setter pairs, getters with a custom event specified or even on the class 
    definition itself (in which case all public properties and getter/setters will become bindable).
  %p.sidebar
    %em
      This
      %code
        [Bindable] 
      tag takes an optional event name parameter that allows you to specify on which event you want the bindings to fire
      and update themselves. Specifying the event looks like this: 
      %code
        [Bindable("myCustomEvent")] 
      and you can use this syntax to trigger
      a bunch of bindings from your class at once or just forcing the binding to update by dispatching that event yourself. The default
      event is called 
      %code
        "propertyChange"
      and is of type 
      %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/events/PropertyChangeEvent.html?allClasses=1", :title => "Flex PropertyChangeEvent docs"}
        PropertyChangeEvent.
      For any built-in Flex components the 
      %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/?allClasses=1", :title => "Flex 4 API docs" }
        API Docs
      will tell you what event triggers a binding for a given bindable property or method although generally speaking you don't need to care.  
  %p.title
    Binding Expressions (MXML)      
  %p
    Also, MXML binding syntax is
    %strong
      awesome! 
    Check this out:
    %p
      = partial 'padawan/binding_example_expressions'
    %p
      Look at
      %code
        text="Running Time: {Math.round( runningTime/1000 )}s"
      \. That one line is doing String interpolation, calling a function and performing math on our bindable variable. When generating
      your binding, the Flex compiler will search the expression for all bindable variables and evaluate the entire expression when
      one of them is triggered. You can pretty much make the expression as complicated as you want, although you should always
      keep code maintainability in mind and only use what you need. You can even bind on chains of properties, like
      %code
        currentUser.dateOfBirth.year
      if you make each step in the chain bindable as well.
  %p.title
    One-Way Bindings in ActionScript 3
  %p
    It's also possible to create bindings purely in AS3. Although this doesn't get you all of the nice benefits of generated code like the
    MXML examples mentioned above, in a pinch you can wire things up like in the following example where we're dynamically setting
    the background and border color of the 
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/spark/primitives/Rect.html?allClasses=1", :title => "Flex 4 Rectangle" }
      Rectangle 
    via the
    %a{ :href => "http://help.adobe.com/en_US/FlashPlatform/beta/reference/actionscript/3/mx/controls/ColorPicker.html?allClasses=1", :title => "Flex Color Picker" }
      ColorPickers:
    = partial 'padawan/binding_example_as3'

  %p
    In short, get to know your bindings and go forth and use them copiously, because a few well placed bindings can DRY up a bunch of event listener
    based code you'd have to write yourself to do the same thing, improving quality and maintainability. Yay.
  %p
    Check out the
    %a{ :href => "http://livedocs.adobe.com/flex/3/html/help.html?content=databinding_8.html", :title => "Flex Data Binding docs"}
      Flex Data Binding docs
    for more information.
%h3
  %a{ :name => "trace" }
    What is trace()?
.definition
  %p
    %code
      trace() 
    is a top-level utility function that lets you output strings to the console (typically inside your IDE) when running the debug version of your application.
  %p
    There are much more efficient ways to debug your application such as using the visual debugger built into  
    %a{ :href => "#flashbuilder", :title => "Adobe Flash Builder" }
      Flash Builder
    or using
    %a{ :href => "http://code.google.com/p/flash-thunderbolt/wiki/ThunderBoltAS3", :title => "Logging for Firebug/Firefox" }
      ThunderBoltAS3
    to output to the log in Firebug/Firefox, but it's the equivalent to 
    %code
      System.out.println 
    in Java or 
    %code
      puts
    in Ruby and so is a simple yet essential tool in your Jedi belt.
  %p
    It works just like you think:
    = partial 'padawan/trace_example'
  %p
    Note that all objects have a built-in 
    %code
      toString()
    method (which you override without the keyword
    %code
      override
    in your custom classes because it's a vestige of prototype-based inheritance) and is called on the target object when you pass it to 
    %code
      trace()
    \. A Class's default 
    %code
      toString() 
    sometimes gives you really useful information and sometimes completely sucks, but you can always try it because you can always pass anything directly into the 
    %code
      trace()
    function.
%h3
  %a{ :name => "racetrack" }
    Bonus: What is the elastic racetrack?  
.definition
  %p
    Flash Player executes your code in cycles that are divided into two main parts: drawing and calculating. Your goal as a Flex developer is
    not only to write code that results in faster cycles overall, but also to write code that achieves a balance between the time the Flash Player 
    spends calculating and rendering. So, if you're drawing a chinaman walking across the screen 100 times per second, but the screen can only refresh
    at 60 times per second, then you are wasting time that could be spent doing other things by drawing the chinaman 40 extra times per second.
  %p
    The best way to ensure that your racetrack stays balanced is to take advantage of the hooks that the Flex framework gives you. Overriding methods like 
    commitProperties(), measure() and updateDisplayList() will let you customize your components as much as you want, but still allow the Flex framework
    to decide when is the optimal time to perform each of these duties. Duties. haha
  %p
    Check out
    %a{ :href => "http://www.craftymind.com/2008/04/18/updated-elastic-racetrack-for-flash-9-and-avm2/", :title => "Updated 'Elastic Racetrack' for Flash 9 and AVM2" }
      this article
    for more details.
%p
  Did I miss something? Leave a comment with your concept and explanation and if it makes sense I'll pull it in like Obi-wan.